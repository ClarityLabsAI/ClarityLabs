<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chladni Plate Radiant Diamond Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            font-family: 'Courier New', Courier, monospace;
            color: #eee;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 24px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        button {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255, 255, 255, 0.8);
            color: #fff;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 20px;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: bold;
        }

        button:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        .status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 14px;
            opacity: 0.8;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            line-height: 1.4;
        }
        
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.07'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
        }

    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="plate"></canvas>
        <div class="overlay"></div>
    </div>

    <div class="status">
        PARTICLES: <span id="p-count">0</span><br>
        MODE: <span id="freq-val" style="color: #888;">NOISE</span>
    </div>

    <div class="controls">
        <button id="btn-scatter">Scatter</button>
        <button id="btn-form">Resonate (Radiant)</button>
    </div>

<script>
(function() {
    /**
     * CONFIGURATION
     */
    const PARTICLE_COUNT = 30000; // High count for clean lines
    const PARTICLE_COLOR = '#f0e8c4'; 
    
    // Plate Dimensions (Rectangular / Horizontal)
    const PLATE_WIDTH = 800; 
    const PLATE_HEIGHT = 550; 
    
    // Physics settings
    const MAX_VELOCITY = 12;     
    const FRICTION = 0.94;      
    const TRAP_FRICTION = 0.6; // High friction when on a line (makes it clean)
    const SENSITIVITY = 0.25;   
    
    const canvas = document.getElementById('plate');
    const ctx = canvas.getContext('2d', { alpha: false });
    const pCountEl = document.getElementById('p-count');
    const freqValEl = document.getElementById('freq-val');

    // Off-screen canvas for the vibration map
    let mapCanvas = document.createElement('canvas');
    let mapCtx = mapCanvas.getContext('2d');
    let mapData;

    let particles = [];
    let isResonating = false;
    let animationId;
    let w, h; 
    let plateX, plateY;

    /**
     * INITIALIZATION
     */
    function init() {
        w = window.innerWidth;
        h = window.innerHeight;
        const dpr = window.devicePixelRatio || 1;
        
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.scale(dpr, dpr);

        // Center the plate rectangle
        plateX = (w - PLATE_WIDTH) / 2;
        plateY = (h - PLATE_HEIGHT) / 2;

        initMap();

        particles = new Float32Array(PARTICLE_COUNT * 4);
        
        // Start scattered everywhere
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i4 = i * 4;
            particles[i4] = Math.random() * w;     
            particles[i4 + 1] = Math.random() * h; 
            particles[i4 + 2] = (Math.random() - 0.5) * MAX_VELOCITY; 
            particles[i4 + 3] = (Math.random() - 0.5) * MAX_VELOCITY; 
        }

        pCountEl.innerText = PARTICLE_COUNT.toLocaleString();
        
        if (animationId) cancelAnimationFrame(animationId);
        animate();
    }

    /**
     * Create the Vibration Map (Horizontal Radiant Cut)
     */
    function initMap() {
        // Create the map exactly the size of the plate
        mapCanvas.width = PLATE_WIDTH;
        mapCanvas.height = PLATE_HEIGHT;
        
        // 1. Fill with White (Max Vibration / Bounce Zone)
        mapCtx.fillStyle = '#ffffff';
        mapCtx.fillRect(0, 0, PLATE_WIDTH, PLATE_HEIGHT);

        // 2. Draw the Pattern in Black (Zero Vibration / Nodes / Safe Zone)
        mapCtx.strokeStyle = '#000000';
        mapCtx.lineCap = 'round';
        mapCtx.lineJoin = 'round';

        const cx = PLATE_WIDTH / 2;
        const cy = PLATE_HEIGHT / 2;
        
        // Scale factors for width and height
        const sw = PLATE_WIDTH / 2; 
        const sh = PLATE_HEIGHT / 2;

        function line(x1, y1, x2, y2, width = 2) {
            mapCtx.lineWidth = width;
            mapCtx.beginPath();
            mapCtx.moveTo(cx + x1 * sw, cy + y1 * sh);
            mapCtx.lineTo(cx + x2 * sw, cy + y2 * sh);
            mapCtx.stroke();
        }

        // --- RADIANT CUT GEOMETRY (HORIZONTAL) ---
        // Coordinates are normalized (-1 to 1), but we scale X and Y independently
        // to stretch it horizontally.
        
        // Outer Rim (Girdle) - Octagon
        const ox = 0.95; // Outer Width
        const oy = 0.95; // Outer Height
        const oc = 0.25; // Corner cut amount
        
        // Inner Table - Octagon
        const ix = 0.55; 
        const iy = 0.55; 
        const ic = 0.15; // Corner cut amount

        // Outer vertices
        const o_tl = [-ox + oc, -oy], o_tr = [ox - oc, -oy];
        const o_rt = [ox, -oy + oc], o_rb = [ox, oy - oc];
        const o_br = [ox - oc, oy], o_bl = [-ox + oc, oy];
        const o_lb = [-ox, oy - oc], o_lt = [-ox, -oy + oc];

        // Inner vertices
        const i_tl = [-ix + ic, -iy], i_tr = [ix - ic, -iy];
        const i_rt = [ix, -iy + ic], i_rb = [ix, iy - ic];
        const i_br = [ix - ic, iy], i_bl = [-ix + ic, iy];
        const i_lb = [-ix, iy - ic], i_lt = [-ix, -iy + ic];

        // Draw Outer Octagon
        line(...o_tl, ...o_tr); line(...o_tr, ...o_rt); line(...o_rt, ...o_rb); line(...o_rb, ...o_br);
        line(...o_br, ...o_bl); line(...o_bl, ...o_lb); line(...o_lb, ...o_lt); line(...o_lt, ...o_tl);

        // Draw Inner Octagon (Table)
        line(...i_tl, ...i_tr); line(...i_tr, ...i_rt); line(...i_rt, ...i_rb); line(...i_rb, ...i_br);
        line(...i_br, ...i_bl); line(...i_bl, ...i_lb); line(...i_lb, ...i_lt); line(...i_lt, ...i_tl);

        // Connect Inner to Outer (Bezel facets)
        line(...i_tl, ...o_tl); line(...i_tr, ...o_tr); 
        line(...i_rt, ...o_rt); line(...i_rb, ...o_rb);
        line(...i_br, ...o_br); line(...i_bl, ...o_bl);
        line(...i_lb, ...o_lb); line(...i_lt, ...o_lt);

        // Star Facets (Triangles on top/bottom/sides)
        // Midpoints
        const om_t = [0, -oy], om_b = [0, oy];
        const om_r = [ox, 0], om_l = [-ox, 0];
        
        // Connect Inner corners to Outer mids
        line(...i_tl, ...om_t); line(...i_tr, ...om_t);
        line(...i_bl, ...om_b); line(...i_br, ...om_b);
        line(...i_rt, ...om_r); line(...i_rb, ...om_r);
        line(...i_lt, ...om_l); line(...i_lb, ...om_l);

        // Diagonals inside table (Keeping these as requested, removing only the cross)
        line(-ix+ic, -iy, ix-ic, iy, 1);
        line(ix-ic, -iy, -ix+ic, iy, 1);
        
        // NO BLUR: We want sharp lines.
        // The physics will check exact pixel brightness. 
        // 0 (Black) = Safe. 255 (White) = Kick.

        mapData = mapCtx.getImageData(0, 0, PLATE_WIDTH, PLATE_HEIGHT).data;
    }

    /**
     * ANIMATION LOOP
     */
    function animate() {
        // Clear entire screen
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, w, h);

        // Draw the "Plate" background (Visual only)
        // Rectangular gradient
        ctx.save();
        ctx.translate(plateX + PLATE_WIDTH/2, plateY + PLATE_HEIGHT/2);
        // Create a gradient that matches the rectangle aspect roughly
        const r = Math.max(PLATE_WIDTH, PLATE_HEIGHT) / 1.5;
        const gradient = ctx.createRadialGradient(0, 0, r/6, 0, 0, r);
        gradient.addColorStop(0, '#222');
        gradient.addColorStop(1, '#050505');
        ctx.fillStyle = gradient;
        ctx.fillRect(-PLATE_WIDTH/2, -PLATE_HEIGHT/2, PLATE_WIDTH, PLATE_HEIGHT);
        
        // Border REMOVED as requested
        // ctx.strokeStyle = '#333';
        // ctx.lineWidth = 2;
        // ctx.strokeRect(-PLATE_WIDTH/2, -PLATE_HEIGHT/2, PLATE_WIDTH, PLATE_HEIGHT);
        
        ctx.restore();


        ctx.fillStyle = PARTICLE_COLOR;

        // Optimization: Pre-calculate bounds
        const pW = PLATE_WIDTH;
        const pH = PLATE_HEIGHT;
        const pX = plateX;
        const pY = plateY;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i4 = i * 4;
            let x = particles[i4];
            let y = particles[i4 + 1];
            let vx = particles[i4 + 2];
            let vy = particles[i4 + 3];

            // --- PHYSICS ---
            
            if (isResonating) {
                // Local coordinates on the plate
                const lx = (x - pX) | 0; // Bitwise floor
                const ly = (y - pY) | 0;

                let amplitude = 1.0; 

                // Is particle inside the plate area?
                if (lx >= 0 && lx < pW && ly >= 0 && ly < pH) {
                    // Sample the map
                    // Since map is black-on-white, Black(0) is node, White(255) is vibrate
                    const idx = (ly * pW + lx) * 4;
                    // We only check the Red channel (it's grayscale)
                    amplitude = mapData[idx] / 255; 
                }
                
                // KICK LOGIC
                if (amplitude > 0.1) { 
                    // It's vibrating! Kick it.
                    const angle = Math.random() * 6.28;
                    // Force depends on amplitude.
                    // If amp is 1 (white), full kick. If 0.2 (gray edge), small kick.
                    const force = amplitude * SENSITIVITY * (Math.random() * 2 + 1);
                    vx += Math.cos(angle) * force;
                    vy += Math.sin(angle) * force;
                    
                    // Standard friction in air
                    vx *= FRICTION;
                    vy *= FRICTION;
                } else {
                    // TRAP LOGIC (It's on a black line!)
                    // Apply HEAVY friction to stop it exactly here.
                    // This creates the "clean" lines.
                    vx *= TRAP_FRICTION;
                    vy *= TRAP_FRICTION;
                }
            } else {
                // Noise Mode
                vx += (Math.random() - 0.5) * 0.2;
                vy += (Math.random() - 0.5) * 0.2;
                vx *= FRICTION;
                vy *= FRICTION;
            }

            x += vx;
            y += vy;

            // Bounce off screen edges
            if (x < 0) { x = 0; vx *= -1; }
            if (x > w) { x = w; vx *= -1; }
            if (y < 0) { y = 0; vy *= -1; }
            if (y > h) { y = h; vy *= -1; }

            particles[i4] = x;
            particles[i4 + 1] = y;
            particles[i4 + 2] = vx;
            particles[i4 + 3] = vy;

            // DRAW: 1x1 pixels are fastest and cleanest
            ctx.fillRect(x, y, 1, 1);
        }

        animationId = requestAnimationFrame(animate);
    }

    /**
     * CONTROLS
     */
    const btnScatter = document.getElementById('btn-scatter');
    const btnForm = document.getElementById('btn-form');

    btnScatter.addEventListener('click', () => {
        isResonating = false;
        freqValEl.innerText = "NOISE";
        freqValEl.style.color = "#888";

        // Big explosion
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i4 = i * 4;
            particles[i4 + 2] = (Math.random() - 0.5) * MAX_VELOCITY * 4;
            particles[i4 + 3] = (Math.random() - 0.5) * MAX_VELOCITY * 4;
        }
    });

    btnForm.addEventListener('click', () => {
        isResonating = true;
        freqValEl.innerText = "RESONATING (RADIANT)";
        freqValEl.style.color = "#4ff";
    });

    window.addEventListener('resize', init);

    // Auto-start
    init();
    setTimeout(() => {
        setTimeout(() => btnForm.click(), 1000);
    }, 100);

})();
</script>
</body>
</html>